@top Script { expression* }

@skip { spaces }

@precedence { command @left, content @left, higher @left, lower @left, comparison @left, not @left, or @left, and @left }

expression {
  !command (Todo | Include | VariableDeclaration | VariableAssignment | LineComment | Choice | Knot | Stitch | BlockComment | Gather) |
  !content (inline | eol)
}

inline {
  Glue? (!command Divert | Dynamic | content)* Glue? !command Divert* tags? eol
}

content {
  (word | EscapedChar)
}

Label { openLabel Identifier ")" }
@skip {} { Todo { todo notEol* eol } }
@skip {} { Include { include notEol* eol } }
@skip {} { Gather { gatherMarker (" " | "\t")* (!command Label) notEol* eol } }
Choice { ChoiceMarker (!command Label)? (!command Condition)* (!higher (Divert | tags) | !lower content) (!higher inline | !lower eol)+ }
Divert { DivertArrow (Target | eol | Divert) }
FunctionArgs { "(" commaSep<Identifier> ")" }
FunctionDeclaration { @specialize[@name="function"]<Identifier, "function"> Identifier }
Knot {
  knotMarker Identifier knotMarker? eol |
  knotMarker FunctionDeclaration FunctionArgs knotMarker? eol
}
Stitch { stitchMarker Identifier eol }
tags { Tag+ eol }
Tag { tagStart TagValue? }
VariableDeclaration { var Identifier "=" VarValue eol }
IncDec { "++" | "--" }
VariableAssignment { tildeId ("=" VarValue | IncDec) eol }
@skip {} { tildeId { "~" Identifier } }
@skip {} { LineComment { "//" commentValue } }
commaSep<content> { "" | content ("," content)* }

binaryConditions {
  or { conditions !or OrOp conditions } |
  and { conditions !and AndOp conditions } |
  comparison { conditions !comparison ComparisonOp conditions }
}

conditions {
  binaryConditions |
  Group { "(" conditions ")" } |
  !not not { !not NotOp conditions } |
  FunctionCall |
  Target |
  Number |
  BooleanLiteral |
  StringLiteral
}

@local tokens {
  stringEnd[@name='"'] { '"' }
  stringEscape { "\\" _ }
  @else stringContent
}

BooleanLiteral { @specialize<Target, "true" | "false"> }
@skip {} { StringLiteral { '"' (stringContent | stringEscape)* stringEnd } }

FunctionCall {
  Target "(" commaSep<Divert | StringLiteral | BooleanLiteral | Number> ")"
}

Condition { "{" conditions "}" }

inlineDynamic {
  (!higher Divert | !higher Dynamic | !lower word)+
}

Dynamic { "{" ~maybeMulti DynamicTypeMarker? Pipe* inlineDynamic (Pipe+ inlineDynamic)* "}" }

MultilineBlock {
  "{" ~maybeMulti 
}

@local tokens {
  blockCommentEnd { "*/" }
  @else blockCommentContent
}

@skip{} {
  BlockComment { !command "/*" blockCommentContent blockCommentEnd }
}

@tokens {
  Number { @digit+ ("." @digit+)? }
  Glue { "<>" }
  openLabel { "(" }
  Pipe { "|" }
  var { "VAR" }
  todo { "TODO:" }
  include { "INCLUDE" }
  OrOp { ("or" | "||") }
  AndOp { ("and" | "&&") }
  NotOp { "not" }
  ComparisonOp { $[<>=] "="? }
  DynamicTypeMarker { "!" | "~" | "&" }
  ChoiceMarker { (starChoice | plusChoice) }
  starChoice { "*"+ }
  plusChoice { "+"+ }
  identifierChar { (identifierStartChar | @digit | $[_]) }
  identifierStartChar { @asciiLetter | $[\u0600-\u06FF\u0530-\u058F\u0400-\u04FF\u0370-\u03FF\u0590-\u05FF\u0100-\u017F\u0180-\u024F\u0080-\u00FF] }
  word { ![\\#~{=\t\n\r|} ] ![ \t\n\r|{}]* }
  TagName { Identifier }
  tagStart { "#" TagName? }
  TagValue { ![#\n]+ }
  VarValue { ![\n]+ }
  commentValue { ![\n]+ }
  eol { $[\n\r] }
  notEol { ![\n\r] }
  EscapedChar { "\\" ![\n\r] }
  knotMarker { "=" "="+ }
  stitchMarker { "=" }
  Identifier { identifierStartChar identifierChar+ }
  Target { Identifier ("." Identifier)*  }
  spaces { $[ \t] }
  gatherMarker { "-"+ }
  DivertArrow { "->" }
  @precedence { spaces, TagValue }
  @precedence { eol, TagValue }
  @precedence { word, spaces }
  @precedence { DivertArrow, gatherMarker, word }
  @precedence { eol, spaces }
  @precedence { VarValue, spaces }
  @precedence { var, word }
  @precedence { todo, word }
  @precedence { include, word }
  @precedence { "~", word }
  @precedence { "//", word }
  @precedence { ChoiceMarker, word }
  @precedence { NotOp, Target }
  @precedence { "/*", word }
  @precedence { knotMarker, stitchMarker }
  @precedence { "}", Pipe, word }
  @precedence { DynamicTypeMarker, word }
  @precedence { openLabel, word, notEol }
  @precedence { Glue, word }
  "{" "}" "<" ">" "="
}

@detectDelim